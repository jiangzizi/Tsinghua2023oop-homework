基因突变
基因突变
题目表述

在某个外星球上，诞生了一种名为 Altset 的微生物，它们的基因可以用一段非空 01 串来描述。这个星球上的环境十分不稳定，因此 Altset 们的基因时刻都在发生突变，突变有 2 种类型：

    将基因的第 jj 位取反（jj 从 00 开始编号）；
    基因最高位增长了一位 0 或 1 ，这会使得基因长度增加。

外星球的空间是有限的，该星球能够容纳 nn 个 Altset，分别记作位置 00 到位置 n−1n−1，刚开始时，仅在位置 00 处有一只 Altset。Altset 会在星球上游来游去，并繁殖自身，具体来说，会发生 2 种事件：

    位置 ii 的 Altset 分裂了自己到位置 jj，这会导致位置 jj 处诞生一个基因片段和位置 ii一模一样的 Altset（保证事件发生时位置 jj 是空的）；
    位置 ii 的 Altset 移动到了位置 jj（保证事件发生时位置 jj 是空的）。

你是一名观测站的科研人员，负责记录并观察这颗星球上 Altset 的进化情况，你的同事有时会问你一个问题：

    查询位置 ii 的 Altset 的基因第 jj 个位置的值。

在所有事件结束后，你还需要统计：

    位置 00 到位置 n−1n−1 的各个 Altset 基因片段中 1 的个数。

输入格式

输入第一行包含 2 个正整数 n,kn,k，其中 nn 表示星球上能够容纳多少个 Altset，kk 表示最早的 Altset 的基因长度。

第二行为一个长度为 kk 的 01 串，表示最早的 Altset 的基因片段，01 串的左边是高位。

第三行包含一个正整数 mm，表示事件个数。

接下来 mm 行，每行输入 3 个数 op,i,jop,i,j，根据其值决定事件类型：

    op=0op=0，将位置 ii 的 Altset 的第 jj 位基因取反；
    op=1op=1，位置 ii 的 Altset 的基因最高位增长了一位，值为 j∈0,1j∈0,1；
    op=2op=2，位置 ii 的 Altset 分裂到位置 jj；
    op=3op=3，位置 ii 的 Altset 移动到位置 jj；
    op=4op=4，查询位置 ii 的 Altset 的第 jj 位基因。

保证以上输入的 i,ji,j 均合法。
输出格式

对于每一个 op=4op=4 的事件，输出一行，0 或 1 表示查询结果。

最后再输出 nn 行，对于第 ii 行，输出一个整数，表示处于位置 i−1i−1 的 Altset 基因片段中 1 的个数。特别地，如果该位置没有 Altset，输出 −1−1。
输入样例

4 3
011
10
0 0 0
3 0 3
4 3 0
1 3 0
1 3 1
4 3 4
1 3 1
2 3 2
0 2 1
4 2 1

输出样例

0
1
0
-1
-1
2
3

限制与约定

1≤n,m≤1051≤n,m≤105；

1≤k≤1031≤k≤103；

保证任意时刻，所有 Altset 基因片段的长度总和不超过 2×1072×107。
要求

    不修改给定的 main.cpp 和 Makefile（下载链接），自行实现 altset.h 和 altset.cpp；
    阅读 main.cpp，并实现对应的接口，使得程序能够正确输出；
    通过给定的 Makefile 可以编译得到可执行文件 main。

提交格式

请将你的文件打包成一个 zip 格式的压缩包并上传。注意：你的文件应该在压缩包的根目录下，而不是压缩包的一个子文件夹下，换而言之，解压你提交的压缩包后，应该直接得到 altset.h 和 altset.cpp，而不是一个包含它们的文件夹。

你不必提交 main.cpp 和 Makefile，评测时，OJ 会将提供的文件贴入你的目录下进行编译并执行。
提示

你的程序并不需要使用 std::bitset（或类似的数据结构）来追求极致的时间效率和空间利用率。
