难缠的店长
题目描述

小陈暑假实习遇到了一个难缠的店长，店长为了将新到的货物进行排序，写了一段代码，但出现了多达12处的语法错误，自诩熟练掌握C++的店长不愿意修改他的代码，请你完善 Rack 类，使得程序可以正常编译运行，提示：合理使用操作符重载和友元函数。首先店长声明了一个 Rack 类代表货架，货架上按顺序储存带有标号的商品，货物的标号为正整数，同一标号的商品可以有多个，初始货架为空。
Subtask1

Rack 类支持通过 += 符号进行货物添加，同时 += 符号也支持添加货架。

Rack A; // 此时货架为空，A：
A += 1; // 给A货架上添加一个标号为1的货物，A：1
A += 3; // 给A货架上添加一个标号为1的货物，A：1 3
A += 7; // 给A货架上添加一个标号为1的货物，A：1 3 7
A += A; // 给A货架上添加A货架上同样的货物，A：1 3 7 1 3 7

Rack 类支持将货架上的货物按顺序打印出来，以供员工按顺序将实际货物排列在货架上。

// 若A：1 3 7 1 3 7   
cout << "A:" << A << endl;
// 输出为：A: 1 3 7 1 3 7\n

Subtask2

Rack 类支持通过 (, , ,) 进行货架和货物的组装。（测例中不会出现相邻的货物，例如：(A, 1, A, 2, A) 是合理的，(1, A, 2, 3, 4, A) 和 (A, 1, 2, 3) 是不合理的）

// 若A：1 3 7
Rack B; // 此时货架为空，B：
B = (A, A); // 将两个A货架拼起来。B：1 3 7 1 3 7
B = (2023, A, 2023, A, 2023, A); // 将三个A货架拼起来，并插入三个编号为2023的货物，此时B：2023 1 3 7 2023 1 3 7 2023 1 3 7

Rack 类支持货架上货物数量的比较，例如A的货物数量比B少，则 (A < B) = 1，(A == B) = 0，(A > B) = 0；

// 若A：1 3 7     B：2023 1 3 7 2023 1 3 7 2023 1 3 7    C:4 6 8
cout << (A < B) << " ";
cout << (C > B) << " ";
cout << (A == C) << endl;
// 输出为：1 0 1\n

Rack 类支持采用 & 按顺序挑选出多个货架中相同的货物。我们规定：对于 F & G，输出货物的顺序和货物在 F 货架上的顺序相同。重复的货物只输出一次。

// 若F：1 2 2 3 4 5   G：2 2 4 3 5 6    H: 7 4 5 6 3 8
Rack D = F & G; // D：2 3 4 5
Rack E = F & G & H; // E：3 4 5

Subtask3

Rack 类支持采用 (int a) 返回货架上标号为 a 的货物的个数。

// 若A：1 2 2 3 3 3   
cout << A(3) << endl;
// 输出为：3

Rack 类支持采用 ~ 将货架上的货物进行倒转顺序。

// 若B：1 2 3 4 5   
~B; // 则B：5 4 3 2 1

Rack 类支持采用 --A 和 A--，两者分别负责将货架上最前面的货物和最后的货物卸下来。

// 若 B：5 4 3 2 1   
B--; // B：5 4 3 2
--B; // B：4 3 2

Subtask4

为了综合应用以上所有的运算，店长写了如下的代码 main.cpp：

#include "Rack.h"
#include <iostream>

int main(){
    Rack A, B, C, D;
    int n = 0, temp = 0;
    cin >> n; // 读入要添加的货物的个数
    for (int i = 0; i < n; i++){ // 初始给A和B货架添加货物
        cin >> temp;
        if (A < B) A += temp; // 如果A上的货物数量比B少就给A上添加货物
        else B += temp;
    } // 经过上述添加货物后，货架A上为第奇数个货物：1 2 4 6 8 9 ，B上为第奇数个货物：1 2 3 5 7 9
    C = (A, 2023, B, 2023); // C货架上按照 {A上的货物, 标号为2023的货物, B上的货物, 标号为2023的货物} 的顺序排列，即货架C为：1 2 4 6 8 9 2023 1 2 3 5 7 9 2023
    cout << "C:" << C << endl; // 将C货架上的元素按照加入的顺序打印出来，然后让店员摆放
    for(int i = 1; i < 5; i++){
        cout << i << ": " << C(i) << endl; // 打印出C货架上标号号为i的货物的个数,若i=1，则此处C[i]=2
    }
    D = A & B; // D由A和B中共有的元素组成,即货架D为：1 2 9
    cout << "D:" << D << endl;
    ~D; // 将C货架上的货物倒序，即货架D为：9 2 1
    D--; // 将D货架上最后一个货物卸掉（直接删掉），即货架D为：9 2 
    --D; // 将D货架上最前面一个货物卸掉（直接删掉），即货架D为：2 
    cout << "D:" << D << endl;
}

下发的文件

    包含以上四个任务的 main.cpp 文件（下载链接）。
    参考 Makefile 文件（下载链接）。可以使用 make exe_i 命令编译出 subtask i 对应的 exe_i 文件。 注：Makefile 中的 -D 参数的含义可以参考此链接。

输入格式：

12
1 1 2 2 3 4 5 6 7 8 9 9

输出格式：

C: 1 2 4 6 8 9 2023 1 2 3 5 7 9 2023
1: 2
2: 2
3: 1
4: 1
D: 1 2 9
D: 2

提交格式

    你只能提交 Rack.cpp 与 Rack.h，我们会将你提交的文件和我们预先设置好的 main.cpp 一起编译运行。
    你应该将你的文件打包成一个zip压缩包并上传。注意：你的文件应该在压缩包的根目录下，而不是压缩包的一个子文件夹下。

评分标准

我们会有1个样例测试点，即下发的main.cpp。另外有1个隐藏测试点，会相应的更改main.cpp中内容进行测试。一般来说，如果你能正确实现通过样例测试点，也应该能够通过隐藏测试点。

测试时分为为了4个 task，每个 task 各占25分。只有你通过了样例测试点和隐藏测试点的同一个 task，你才能获得该 subtask 的分数。四个 subtask 对应的测试点编号分别为：(1,5)，(2,6)，(3,7)，(4,8)

注意你不用同时通过4个task再提交，仅仅实现部分 task 的代码也能得到部分分（但是后一个 task 可能会依赖于前一个 task）。同时请保证提交的 Rack.cpp 与 Rack.h 和下发的 main.cpp 能够一起编译成功。

考试100%为OJ评分。
